# JSON encoder and decoder implementation
# Based on Python standard library json module

import re
import sys
import struct
from io import StringIO
from collections.abc import Mapping, Sequence


__all__ = [
    'dump', 'dumps', 'load', 'loads',
    'JSONDecoder', 'JSONEncoder',
]


class JSONEncoder:
    """Extensible JSON encoder

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict              | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str               | string        |
    +-------------------+---------------+
    | int, float        | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+
    """

    def __init__(self, *, skipkeys=False, ensure_ascii=True,
                 check_circular=True, allow_nan=True, sort_keys=False,
                 indent=None, separators=None, default=None):
        """Constructor for JSONEncoder, with sensible defaults."""

        self.skipkeys = skipkeys
        self.ensure_ascii = ensure_ascii
        self.check_circular = check_circular
        self.allow_nan = allow_nan
        self.sort_keys = sort_keys
        self.indent = indent

        if separators is not None:
            self.item_separator, self.key_separator = separators
        elif indent is not None:
            self.item_separator = ','
        else:
            self.item_separator = ', '
            self.key_separator = ': '

        if default is not None:
            self.default = default

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
        """
        raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')

    def encode(self, o):
        """Return a JSON string representation of a Python data structure."""
        if isinstance(o, str):
            return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because
        # the iterator is not guaranteed to be reusable
        chunks = self.iterencode(o, _one_shot=True)
        if not isinstance(chunks, (list, tuple)):
            chunks = list(chunks)
        return ''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string representation as available."""
        if self.check_circular:
            markers = {}
        else:
            markers = None

        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring

        def floatstr(o, allow_nan=self.allow_nan):
            # Check for specials
            if o != o:
                text = 'NaN'
            elif o == float('inf'):
                text = 'Infinity'
            elif o == float('-inf'):
                text = '-Infinity'
            else:
                return repr(o)

            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))
            return text


# Collections module - High-performance container datatypes

from collections.abc import MutableMapping
from operator import itemgetter
from heapq import nlargest
from itertools import repeat, chain


class Counter(dict):
    """Dict subclass for counting hashable items.

    Sometimes called a bag or multiset. Elements are stored as dictionary keys
    and their counts are stored as dictionary values.

    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string
    >>> c.most_common(3)                # three most common elements
    [('a', 5), ('b', 4), ('c', 3)]
    """

    def __init__(self, iterable=None, /, **kwds):
        """Create a new, empty Counter object."""
        super().__init__()
        self.update(iterable, **kwds)

    def __missing__(self, key):
        """The count of elements not in the Counter is zero."""
        return 0

    def most_common(self, n=None):
        """List the n most common elements and their counts.

        If n is None, then list all element counts.
        """
        if n is None:
            return sorted(self.items(), key=itemgetter(1), reverse=True)
        return nlargest(n, self.items(), key=itemgetter(1))

    def elements(self):
        """Iterator over elements repeating each as many times as its count."""
        return chain.from_iterable(map(repeat, self.items(), self.values()))

    def update(self, iterable=None, /, **kwds):
        """Like dict.update() but add counts instead of replacing them."""
        if iterable is not None:
            if isinstance(iterable, Mapping):
                if self:
                    self_get = self.get
                    for elem, count in iterable.items():
                        self[elem] = count + self_get(elem, 0)
                else:
                    super().update(iterable)
            else:
                self_get = self.get
                for elem in iterable:
                    self[elem] = 1 + self_get(elem, 0)

        if kwds:
            self.update(kwds)

    def subtract(self, iterable=None, /, **kwds):
        """Subtract count, but keep only results with positive counts."""
        if iterable is not None:
            self_get = self.get
            if isinstance(iterable, Mapping):
                for elem, count in iterable.items():
                    self[elem] = self_get(elem, 0) - count
            else:
                for elem in iterable:
                    self[elem] = self_get(elem, 0) - 1

        if kwds:
            self.subtract(kwds)


# Threading module - Thread-based parallelism

import time
import warnings
from time import monotonic as _time
from traceback import format_exc as _format_exc
from collections import deque
from itertools import count as _count


class Thread:
    """A class that represents a thread of control.

    This class can be safely subclassed in a limited fashion.
    """

    _initialized = False

    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, *, daemon=None):
        """Initialize a Thread.

        This constructor should always be called with keyword arguments.
        """
        assert group is None, "group argument must be None for now"

        if kwargs is None:
            kwargs = {}

        self._target = target
        self._name = str(name or _newname())
        self._args = args
        self._kwargs = kwargs

        if daemon is not None:
            self._daemonic = daemon
        else:
            self._daemonic = current_thread().daemon

        self._ident = None
        self._native_id = None
        self._started = Event()
        self._is_stopped = False
        self._initialized = True

    def start(self):
        """Start the thread's activity."""
        if not self._initialized:
            raise RuntimeError("thread.__init__() not called")

        if self._started.is_set():
            raise RuntimeError("threads can only be started once")

        with _active_limbo_lock:
            _limbo[self] = self

        try:
            _start_new_thread(self._bootstrap, ())
        except Exception:
            with _active_limbo_lock:
                del _limbo[self]
            raise

        self._started.wait()

    def run(self):
        """Method representing the thread's activity."""
        try:
            if self._target is not None:
                self._target(*self._args, **self._kwargs)
        finally:
            del self._target, self._args, self._kwargs

    def join(self, timeout=None):
        """Wait until the thread terminates."""
        if not self._initialized:
            raise RuntimeError("Thread.__init__() not called")

        if not self._started.is_set():
            raise RuntimeError("cannot join thread before it is started")

        if self is current_thread():
            raise RuntimeError("cannot join current thread")

        if timeout is None:
            self._wait_for_tstate_lock()
        else:
            self._wait_for_tstate_lock(timeout=max(timeout, 0))


# itertools - Functions creating iterators for efficient looping

class cycle:
    """Return elements from the iterable until it is exhausted.
    Then repeat the sequence indefinitely.
    """

    def __init__(self, iterable):
        self.iterable = iterable
        self.saved = []
        self.index = 0
        self.firstpass = True

    def __iter__(self):
        return self

    def __next__(self):
        if self.firstpass:
            try:
                value = next(self.iterable)
                self.saved.append(value)
                return value
            except StopIteration:
                self.firstpass = False
                self.index = 0

        if not self.saved:
            raise StopIteration

        value = self.saved[self.index]
        self.index = (self.index + 1) % len(self.saved)
        return value


def chain(*iterables):
    """Chain multiple iterables together."""
    for it in iterables:
        yield from it


def compress(data, selectors):
    """Return data elements corresponding to true selector elements."""
    return (d for d, s in zip(data, selectors) if s)
