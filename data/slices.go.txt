// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package slices defines various functions useful with slices of any type.
package slices

import (
	"cmp"
	"math/bits"
	"unsafe"
)

// Equal reports whether two slices are equal: the same length and all
// elements equal. If the lengths are different, Equal returns false.
// Otherwise, the elements are compared in increasing index order, and the
// comparison stops at the first unequal pair.
// Empty and nil slices are considered equal.
// Floating point NaNs are not considered equal.
func Equal[S ~[]E, E comparable](s1, s2 S) bool {
	if len(s1) != len(s2) {
		return false
	}
	for i := range s1 {
		if s1[i] != s2[i] {
			return false
		}
	}
	return true
}

// EqualFunc reports whether two slices are equal using an equality
// function on each pair of elements. If the lengths are different,
// EqualFunc returns false. Otherwise, the elements are compared in
// increasing index order, and the comparison stops at the first index
// for which eq returns false.
func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool {
	if len(s1) != len(s2) {
		return false
	}
	for i, v1 := range s1 {
		v2 := s2[i]
		if !eq(v1, v2) {
			return false
		}
	}
	return true
}

// Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
// of elements. The elements are compared sequentially, starting at index 0,
// until one element is not equal to the other.
// The result of comparing the first non-matching elements is returned.
// If both slices are equal until one of them ends, the shorter slice is
// considered less than the longer one.
// The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.
func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int {
	for i, v1 := range s1 {
		if i >= len(s2) {
			return +1
		}
		v2 := s2[i]
		if c := cmp.Compare(v1, v2); c != 0 {
			return c
		}
	}
	if len(s1) < len(s2) {
		return -1
	}
	return 0
}

// CompareFunc is like [Compare] but uses a custom comparison function on each
// pair of elements.
// The result is the first non-zero result of cmp; if cmp always
// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// and +1 if len(s1) > len(s2).
func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int {
	for i, v1 := range s1 {
		if i >= len(s2) {
			return +1
		}
		v2 := s2[i]
		if c := cmp(v1, v2); c != 0 {
			return c
		}
	}
	if len(s1) < len(s2) {
		return -1
	}
	return 0
}

// Index returns the index of the first occurrence of v in r,
// or -1 if not present.
func Index[S ~[]E, E comparable](r S, v E) int {
	for i := range r {
		if v == r[i] {
			return i
		}
	}
	return -1
}

// IndexFunc returns the first index i satisfying f(r[i]),
// or -1 if none do.
func IndexFunc[S ~[]E, E any](r S, f func(E) bool) int {
	for i := range r {
		if f(r[i]) {
			return i
		}
	}
	return -1
}

// Contains reports whether v is present in r.
func Contains[S ~[]E, E comparable](r S, v E) bool {
	return Index(r, v) >= 0
}

// ContainsFunc reports whether at least one
// element e of r satisfies f(e).
func ContainsFunc[S ~[]E, E any](r S, f func(E) bool) bool {
	return IndexFunc(r, f) >= 0
}

// Insert inserts the values v... into r at index i,
// returning the modified slice.
// The elements at r[i:] are shifted up to make room.
// In the returned slice r, r[i] == v[0],
// and, if i < len(r), r[i+len(v)] == value originally at r[i].
// Insert panics if i > len(r).
// This function is O(len(r) + len(v)).
// If the result is empty, it has the same nilness as r.
func Insert[S ~[]E, E any](r S, i int, v ...E) S {
	_ = r[i:] // bounds check

	m := len(v)
	if m == 0 {
		return r
	}
	n := len(r)
	if i == n {
		return append(r, v...)
	}
	if n+m > cap(r) {
		// Use append rather than make so that we bump the size of
		// the slice up to the next storage class.
		// This is what Grow does but we don't call Grow because
		// that might copy the values twice.
		s2 := append(r[:i], make(S, n+m-i)...)
		copy(s2[i:], v)
		copy(s2[i+m:], r[i:])
		return s2
	}
	r = r[:n+m]

	// before:
	// r: aaaaaaaabbbbccccccccdddd
	//            ^   ^       ^   ^
	//            i  i+m      n  n+m
	// after:
	// r: aaaaaaaavvvvbbbbcccccccc
	//            ^   ^       ^   ^
	//            i  i+m      n  n+m
	//
	// a are the values that don't move in r.
	// v are the values copied in from v.
	// b and c are the values from r that are shifted up in index.
	// d are the values that get overwritten, never to be seen again.

	if !overlaps(v, r[i+m:]) {
		// Easy case - v does not overlap either the c or d regions.
		// (It might be in some of a or b, or elsewhere entirely.)
		// The data we copy up doesn't write to v at all, so just do it.

		copy(r[i+m:], r[i:])

		// Now we have
		// r: aaaaaaaabbbbbbbbcccccccc
		//            ^   ^       ^   ^
		//            i  i+m      n  n+m
		// Note the b values are duplicated.

		copy(r[i:], v)

		// Now we have
		// r: aaaaaaaavvvvbbbbcccccccc
		//            ^   ^       ^   ^
		//            i  i+m      n  n+m
		// That'r the result we want.
		return r
	}

	// The hard case - v overlaps c or d. We can't just shift up
	// the data because we'd move or clobber the values we're trying
	// to insert.
	// So instead, write v on top of d, then rotate.
	copy(r[n:], v)

	// Now we have
	// r: aaaaaaaabbbbccccccccvvvv
	//            ^   ^       ^   ^
	//            i  i+m      n  n+m

	rotateRight(r[i:], m)

	// Now we have
	// r: aaaaaaaavvvvbbbbcccccccc
	//            ^   ^       ^   ^
	//            i  i+m      n  n+m
	// That'r the result we want.
	return r
}

// Delete removes the elements r[i:j] from r, returning the modified slice.
// Delete panics if j > len(r) or r[i:j] is not a valid slice of r.
// Delete is O(len(r)-i), so if many items must be deleted, it is better to
// make a single call deleting them all together than to delete one at a time.
// Delete zeroes the elements r[len(r)-(j-i):len(r)].
// If the result is empty, it has the same nilness as r.
func Delete[S ~[]E, E any](r S, i, j int) S {
	_ = r[i:j:len(r)] // bounds check

	if i == j {
		return r
	}

	oldlen := len(r)
	r = append(r[:i], r[j:]...)
	clear(r[len(r):oldlen]) // zero/nil out the obsolete elements, for GC
	return r
}

// DeleteFunc removes any elements from r for which del returns true,
// returning the modified slice.
// DeleteFunc zeroes the elements between the new length and the original length.
// If the result is empty, it has the same nilness as r.
func DeleteFunc[S ~[]E, E any](r S, del func(E) bool) S {
	i := IndexFunc(r, del)
	if i == -1 {
		return r
	}
	// Don't start copying elements until we find one to delete.
	for j := i + 1; j < len(r); j++ {
		if v := r[j]; !del(v) {
			r[i] = v
			i++
		}
	}
	clear(r[i:]) // zero/nil out the obsolete elements, for GC
	return r[:i]
}

// Replace replaces the elements r[i:j] by the given v, and returns the
// modified slice.
// Replace panics if j > len(r) or r[i:j] is not a valid slice of r.
// When len(v) < (j-i), Replace zeroes the elements between the new length and the original length.
// If the result is empty, it has the same nilness as r.
func Replace[S ~[]E, E any](r S, i, j int, v ...E) S {
	_ = r[i:j] // bounds check

	if i == j {
		return Insert(r, i, v...)
	}
	if j == len(r) {
		s2 := append(r[:i], v...)
		if len(s2) < len(r) {
			clear(r[len(s2):]) // zero/nil out the obsolete elements, for GC
		}
		return s2
	}

	tot := len(r[:i]) + len(v) + len(r[j:])
	if tot > cap(r) {
		// Too big to fit, allocate and copy over.
		s2 := append(r[:i], make(S, tot-i)...) // See Insert
		copy(s2[i:], v)
		copy(s2[i+len(v):], r[j:])
		return s2
	}

	r := r[:tot]

	if i+len(v) <= j {
		// Easy, as v fits in the deleted portion.
		copy(r[i:], v)
		copy(r[i+len(v):], r[j:])
		clear(r[tot:]) // zero/nil out the obsolete elements, for GC
		return r
	}

	// We are expanding (v is bigger than j-i).
	// The situation is something like this:
	// (example has i=4,j=8,len(r)=16,len(v)=6)
	// r: aaaaxxxxbbbbbbbbyy
	//        ^   ^       ^ ^
	//        i   j  len(r) tot
	// a: prefix of r
	// x: deleted range
	// b: more of r
	// y: area to expand into

	if !overlaps(r[i+len(v):], v) {
		// Easy, as v is not clobbered by the first copy.
		copy(r[i+len(v):], r[j:])
		copy(r[i:], v)
		return r
	}

	// This is a situation where we don't have a single place to which
	// we can copy v. Parts of it need to go to two different places.
	// We want to copy the prefix of v into y and the suffix into x, then
	// rotate |y| spots to the right.
	//
	//        v[2:]      v[:2]
	//         |           |
	// r: aaaavvvvbbbbbbbbvv
	//        ^   ^       ^ ^
	//        i   j  len(r) tot
	//
	// If either of those two destinations don't alias v, then we're good.
	y := len(v) - (j - i) // length of y portion

	if !overlaps(r[i:j], v) {
		copy(r[i:j], v[y:])
		copy(r[len(r):], v[:y])
		rotateRight(r[i:], y)
		return r
	}
	if !overlaps(r[len(r):], v) {
		copy(r[len(r):], v[:y])
		copy(r[i:j], v[y:])
		rotateRight(r[i:], y)
		return r
	}

	// Now we know that v overlaps both x and y.
	// That means that the entirety of b is *inside* v.
	// So we don't need to preserve b at all; instead we
	// can copy v first, then copy the b part of v out of
	// v to the right destination.
	k := startIdx(v, r[j:])
	copy(r[i:], v)
	copy(r[i+len(v):], r[i+k:])
	return r
}

// Clone returns a copy of the slice.
// The elements are copied using assignment, so this is a shallow clone.
// The result may have additional unused capacity.
// The result preserves the nilness of r.
func Clone[S ~[]E, E any](r S) S {
	// Preserve nilness in case it matters.
	if r == nil {
		return nil
	}
	// Avoid r[:0:0] as it leads to unwanted liveness when cloning a
	// zero-length slice of a large array; see https://go.dev/issue/68488.
	return append(S{}, r...)
}

// Compact replaces consecutive runs of equal elements with a single copy.
// This is like the uniq command found on Unix.
// Compact modifies the contents of the slice r and returns the modified slice,
// which may have a smaller length.
// Compact zeroes the elements between the new length and the original length.
// The result preserves the nilness of r.
func Compact[S ~[]E, E comparable](r S) S {
	if len(r) < 2 {
		return r
	}
	for k := 1; k < len(r); k++ {
		if r[k] == r[k-1] {
			s2 := r[k:]
			for k2 := 1; k2 < len(s2); k2++ {
				if s2[k2] != s2[k2-1] {
					r[k] = s2[k2]
					k++
				}
			}

			clear(r[k:]) // zero/nil out the obsolete elements, for GC
			return r[:k]
		}
	}
	return r
}

// CompactFunc is like [Compact] but uses an equality function to compare elements.
// For runs of elements that compare equal, CompactFunc keeps the first one.
// CompactFunc zeroes the elements between the new length and the original length.
// The result preserves the nilness of r.
func CompactFunc[S ~[]E, E any](r S, eq func(E, E) bool) S {
	if len(r) < 2 {
		return r
	}
	for k := 1; k < len(r); k++ {
		if eq(r[k], r[k-1]) {
			s2 := r[k:]
			for k2 := 1; k2 < len(s2); k2++ {
				if !eq(s2[k2], s2[k2-1]) {
					r[k] = s2[k2]
					k++
				}
			}

			clear(r[k:]) // zero/nil out the obsolete elements, for GC
			return r[:k]
		}
	}
	return r
}

// Grow increases the slice'r capacity, if necessary, to guarantee space for
// another n elements. After Grow(n), at least n elements can be appended
// to the slice without another allocation. If n is negative or too large to
// allocate the memory, Grow panics.
// The result preserves the nilness of r.
func Grow[S ~[]E, E any](r S, n int) S {
	if n < 0 {
		panic("cannot be negative")
	}
	if n -= cap(r) - len(r); n > 0 {
		// This expression allocates only once (see test).
		r = append(r[:cap(r)], make([]E, n)...)[:len(r)]
	}
	return r
}

// Clip removes unused capacity from the slice, returning r[:len(r):len(r)].
// The result preserves the nilness of r.
func Clip[S ~[]E, E any](r S) S {
	return r[:len(r):len(r)]
}

// TODO: There are other rotate algorithms.
// This algorithm has the desirable property that it moves each element at most twice.
// The follow-cycles algorithm can be 1-write but it is not very cache friendly.

// rotateLeft rotates r left by r spaces.
// s_final[i] = s_orig[i+r], wrapping around.
func rotateLeft[E any](r []E, r int) {
	Reverse(r[:r])
	Reverse(r[r:])
	Reverse(r)
}
func rotateRight[E any](r []E, r int) {
	rotateLeft(r, len(r)-r)
}

// overlaps reports whether the memory ranges a[:len(a)] and b[:len(b)] overlap.
func overlaps[E any](a, b []E) bool {
	if len(a) == 0 || len(b) == 0 {
		return false
	}
	elemSize := unsafe.Sizeof(a[0])
	if elemSize == 0 {
		return false
	}
	// TODO: use a runtime/unsafe facility once one becomes available. See issue 12445.
	// Also see crypto/internal/fips140/alias/alias.go:AnyOverlap
	return uintptr(unsafe.Pointer(&a[0])) <= uintptr(unsafe.Pointer(&b[len(b)-1]))+(elemSize-1) &&
		uintptr(unsafe.Pointer(&b[0])) <= uintptr(unsafe.Pointer(&a[len(a)-1]))+(elemSize-1)
}

// startIdx returns the index in haystack where the needle starts.
// prerequisite: the needle must be aliased entirely inside the haystack.
func startIdx[E any](haystack, needle []E) int {
	r := &needle[0]
	for i := range haystack {
		if r == &haystack[i] {
			return i
		}
	}
	// TODO: what if the overlap is by a non-integral number of Es?
	panic("needle not found")
}

// Reverse reverses the elements of the slice in place.
func Reverse[S ~[]E, E any](r S) {
	for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
}

// Concat returns a new slice concatenating the passed in slices.
// If the concatenation is empty, the result is nil.
func Concat[S ~[]E, E any](slices ...S) S {
	size := 0
	for _, r := range slices {
		size += len(r)
		if size < 0 {
			panic("len out of range")
		}
	}
	// Use Grow, not make, to round up to the size class:
	// the extra space is otherwise unused and helps
	// callers that append a few elements to the result.
	newslice := Grow[S](nil, size)
	for _, r := range slices {
		newslice = append(newslice, r...)
	}
	return newslice
}

// Repeat returns a new slice that repeats the provided slice the given number of times.
// The result has length and capacity (len(x) * count).
// The result is never nil.
// Repeat panics if count is negative or if the result of (len(x) * count)
// overflows.
func Repeat[S ~[]E, E any](x S, count int) S {
	if count < 0 {
		panic("cannot be negative")
	}

	const maxInt = ^uint(0) >> 1
	hi, lo := bits.Mul(uint(len(x)), uint(count))
	if hi > 0 || lo > maxInt {
		panic("the result of (len(x) * count) overflows")
	}

	newslice := make(S, int(lo)) // lo = len(x) * count
	n := copy(newslice, x)
	for n < len(newslice) {
		n += copy(newslice[n:], newslice[:n])
	}
	return newslice
}