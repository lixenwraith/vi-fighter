package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

type ComponentDef struct {
	Field string
	Type  string
}

type SystemDef struct {
	Name        string
	Constructor string
}

type RendererDef struct {
	Name        string
	Constructor string
	Priority    string
}

type Definitions struct {
	Components []ComponentDef
	Systems    []SystemDef
	Renderers  []RendererDef
}

func main() {
	defs := parseDefinitions("definition.go") // cwd is 'manifest/'

	generateFile("../engine/component_store_gen.go", componentStoreTemplate, defs)
	generateFile("register_gen.go", registerTemplate, defs)

	fmt.Printf("Generated: %d components, %d systems, %d renderers\n",
		len(defs.Components), len(defs.Systems), len(defs.Renderers))
}

func parseDefinitions(path string) Definitions {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, path, nil, 0)
	if err != nil {
		panic(fmt.Sprintf("parse %s: %v", path, err))
	}

	var defs Definitions

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			vs, ok := spec.(*ast.ValueSpec)
			if !ok || len(vs.Names) == 0 || len(vs.Values) == 0 {
				continue
			}

			name := vs.Names[0].Name
			comp, ok := vs.Values[0].(*ast.CompositeLit)
			if !ok {
				continue
			}

			switch name {
			case "Components":
				defs.Components = parseComponents(comp)
			case "Systems":
				defs.Systems = parseSystems(comp)
			case "Renderers":
				defs.Renderers = parseRenderers(comp)
			}
		}
	}

	return defs
}

func parseComponents(comp *ast.CompositeLit) []ComponentDef {
	var result []ComponentDef
	for _, elt := range comp.Elts {
		lit, ok := elt.(*ast.CompositeLit)
		if !ok || len(lit.Elts) < 2 {
			continue
		}
		result = append(result, ComponentDef{
			Field: extractString(lit.Elts[0]),
			Type:  extractString(lit.Elts[1]),
		})
	}
	return result
}

func parseSystems(comp *ast.CompositeLit) []SystemDef {
	var result []SystemDef
	for _, elt := range comp.Elts {
		lit, ok := elt.(*ast.CompositeLit)
		if !ok || len(lit.Elts) < 2 {
			continue
		}
		result = append(result, SystemDef{
			Name:        extractString(lit.Elts[0]),
			Constructor: extractString(lit.Elts[1]),
		})
	}
	return result
}

func parseRenderers(comp *ast.CompositeLit) []RendererDef {
	var result []RendererDef
	for _, elt := range comp.Elts {
		lit, ok := elt.(*ast.CompositeLit)
		if !ok || len(lit.Elts) < 3 {
			continue
		}
		result = append(result, RendererDef{
			Name:        extractString(lit.Elts[0]),
			Constructor: extractString(lit.Elts[1]),
			Priority:    extractString(lit.Elts[2]),
		})
	}
	return result
}

func extractString(expr ast.Expr) string {
	lit, ok := expr.(*ast.BasicLit)
	if !ok {
		return ""
	}
	return strings.Trim(lit.Value, `"`)
}

func generateFile(path string, tmpl *template.Template, data any) {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(fmt.Sprintf("template %s: %v", path, err))
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted for debugging
		os.WriteFile(path+".err", buf.Bytes(), 0644)
		panic(fmt.Sprintf("gofmt %s: %v", path, err))
	}

	if err := os.WriteFile(path, formatted, 0644); err != nil {
		panic(fmt.Sprintf("write %s: %v", path, err))
	}
}

var componentStoreTemplate = template.Must(template.New("store").Parse(`// Code generated by gen-manifest; DO NOT EDIT.

package engine

import (
	"github.com/lixenwraith/vi-fighter/component"
	"github.com/lixenwraith/vi-fighter/core"
)

// Component provides typed component store pointers
// Embedded in World, initialized once at world creation
type Component struct {
{{- range .Components }}
	{{ .Field }} *Store[component.{{ .Type }}]
{{- end }}
}

// initComponents creates all component stores
// Called once from NewWorld()
func initComponents(w *World) {
{{- range .Components }}
	w.Component.{{ .Field }} = NewStore[component.{{ .Type }}]()
{{- end }}
	w.Position = NewPosition()
	w.Position.SetWorld(w)
}

// removeEntity removes entity from every component store
func (w *World) removeEntity(e core.Entity) {
{{- range .Components }}
	w.Component.{{ .Field }}.RemoveComponent(e)
{{- end }}
	w.Position.RemoveComponent(e)
}

// wipeAll clears all component stores
func (w *World) wipeAll() {
{{- range .Components }}
	w.Component.{{ .Field }}.ClearAllComponent()
{{- end }}
	w.Position.ClearAllComponent()
}
`))

var registerTemplate = template.Must(template.New("register").Parse(`// Code generated by gen-manifest; DO NOT EDIT.

package manifest

import (
	"github.com/lixenwraith/vi-fighter/engine"
	"github.com/lixenwraith/vi-fighter/registry"
	"github.com/lixenwraith/vi-fighter/render"
	"github.com/lixenwraith/vi-fighter/render/renderers"
	"github.com/lixenwraith/vi-fighter/system"
)

// RegisterSystems registers all system factories with the registry
func RegisterSystems() {
{{- range .Systems }}
	registry.RegisterSystem("{{ .Name }}", func(w any) any {
		return system.{{ .Constructor }}(w.(*engine.World))
	})
{{- end }}
}

// RegisterRenderers registers all renderer factories with priorities
func RegisterRenderers() {
{{- range .Renderers }}
	registry.RegisterRenderer("{{ .Name }}", func(ctx any) any {
		return renderers.{{ .Constructor }}(ctx.(*engine.GameContext))
	}, render.{{ .Priority }})
{{- end }}
}

// ActiveSystems returns the ordered list of systems to instantiate
func ActiveSystems() []string {
	return []string{
{{- range .Systems }}
		"{{ .Name }}",
{{- end }}
	}
}

// ActiveRenderers returns the ordered list of renderers to instantiate
func ActiveRenderers() []string {
	return []string{
{{- range .Renderers }}
		"{{ .Name }}",
{{- end }}
	}
}
`))